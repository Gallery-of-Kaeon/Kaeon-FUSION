Native Definitions
	
	Overview
		
		-
			When Kaeon FUSION code is cross compiled to C, the user must take into account how the
			code will take effect once cross compiled.
		-
	
	Literals
		
		-
			If a command has no children and its content does not match the name of a declared
			variable, function, or structure, it will be cross compiled as a literal. If the
			literal is not a number, it will automatically be placed in quotation marks.
			
			The literals true and false will be cross compiled to 1 and 0 respectively.
			
			For example:
				
				abc
				123
				true
			
			will be cross compiled to:
				
				"abc"
				123
				1
		-
	
	Variables
		
		-
			Variables may be declared as they normally are in FUSION. To create a variable without
			assigning it a variable, you may assign it a value of "Default".
			
			For example:
				
				x: 0
				y: Default
			
			will be cross compiled to:
				
				void* x = 0;
				void* y;
		-
	
	Data Types
		
		-
			Data in Native Code must be strongly typed. Therefore, the data types of functions and
			variables in Kaeon FUSION code that is meant to be cross compiled should be specified
			in meta commands. If no type is specified, any variables declared will be cross
			compiled to void pointers.
			
			The data types recognized by the cross compiler are listed below, alongside how they
			correspond to data types in C:
			
				Integer: int
				Short: short
				Long: long
				Float: float
				Double: double
				Character: char
			
			The attributes recognized by the cross compiler are listed below, alongside how they
			correspond to attributes in C:
			
				Static: static
				Automatic: auto
				External: extern
				Volatile: volatile
			
			For example:
				
				a: "hello"
				
				Meta: Integer
				
				x: 0
				y: 5
				
				Meta: Double
				
				z: 1.5
			
			will be cross compiled to:
				
				void* a = "hello";
				int x = 0;
				int y = 5;
				double z = 1.5;
			
			The user may also specify a data type as a pointer or an address by including "Pointer"
			or "Address" respectively within the meta command.
			
			For example:
				
				Meta: Integer, Pointer
				
				x: Default
			
			will be cross compiled to:
				
				int* x;
			
			In addition, the user may also specify a data type as an array by placing "List" within
			the meta command. Numbers nested withing the list element specify the dimensions of the
			list;
			
			For example:
				
				Meta: Integer, List: 100
				x: Default
				
				Meta: Integer, List: 1, 2, 3
				x: Default
			
			will be cross compiled to:
				
				int x[1][2][3];
			
			If a meta command has an element with the content "Used", the items affected by the
			meta command will be recognized by the cross compiler but will not be defined in the
			compiled code. This should be used when the function has been declared in an included
			header file.
			
			For example:
				
				Define: foo
				
					Use: stdio.h
				
					printf: ABC
					printf: XYZ
					printf: 123
			
			will be cross compiled to:
				
				void foo() {
					void* printf = "ABC";
					printf = "XYZ";
					printf = "123";
				}
			
			However, this:
				
				Define: Meta { Used } printf
				
				Define: foo
				
					Use: stdio.h
				
					printf: ABC
					printf: XYZ
					printf: 123
			
			will be cross compiled to:
			
				#include "stdio.h"
				
				void foo() {
					printf("ABC");
					printf("XYZ");
					printf("123");
				}
			
			As an alternative, the user may nest the command "In: Default" within a scope.
			
			For example:
				
				Scope { In: Default }
					printf: Hello world!
			
			will be cross compiled to:
				
				printf("Hello world!");
			
			even if the printf function was not defined within the FUSION code.
		-
	
	Functions
		
		-
			Every definition used by the cross compiled code will be cross compiled to a function
			in C. Meta tags may be used to specify information regarding a function's return type
			and its parameters. The data type for each parameter should be specified under a takes
			command.
			
			For example:
				
				Define
					
					Meta
						Integer
						Pointer
						Takes: Double
						Takes: Integer, Pointer
					
					foo
						Return
							Add
								Address: At: Arguments, 1
								At: Arguments, 2
			
			will be cross compiled to:
				
				int* foo(double arg1, int* arg2) {
					return &arg1 + arg2;
				}
			
			To return the function, the return command may be used.
			
			For example:
				
				Define: foo
					Return: 3
			
			Will be cross compiled to:
				
				void foo() {
					return 3;
				}
		-
	
	Function arguments
		
		-
			The arguments of a functions may be accessed as a list using the arguments command.
			
			For example:
				
				At: Arguments, 1
			
			will be cross compiled to:
				
				arg1
		-
	
	Global Varaibles
		
		-
			Any variables declared within a global command will be declared outside the function
			when cross compiled.
			
			For example:
				
				Define
					
					foo
					
						Global { Meta: Integer, External }
							x: Default
							y: Default
						
						return: Add: x, y
			
			will be cross compiled to:
				
				extern int x;
				extern int y;
				
				void foo() {
					return x + y;
				}
		-
	
	Structures
		
		-
			Structures may be defined by placing "Structure" in the meta command before a function
			definition.
			
			For example:
				
				Meta: Structure
				
				Define: foo
					
					Meta: Integer
					
					x: Default
					y: Default
					z: Default
			
			will be cross compiled to:
				
				struct foo {
					int x;
					int y;
					int z;
				}
			
			Once defined, structures may be used as varaible types.
			
			For example, if the previously declared structure had already been defined, then:
				
				Meta: foo
				x: Default
			
			will be cross compiled to:
				
				struct foo x;
			
			To call functions within a structure, an in command with the name of the structure as
			its first child nested in a scope command may be used.
			
			To return content from within a scope, the return command may be used.
			
			For example, if the code in the last two examples had already been written, then:
				
				Scope { In: x }
					foo: 50
			
			will cross compile to:
				
				x.foo(50);
				
			and:
			
				Scope { In: x }
					Return: z
			
			will cross compile to:
				
				x.z
		-
	
	Casting
		
		-
			To cast a variable from one data type to another, the cast command may be used.
			
			For example:
				
				Meta: Double
				x: 1.5
				
				Meta: Integer
				y: Cast: x, Integer
			
			will be cross compiled to:
				
				double x = 1.5;
				int y = ((double) x);
		-
	
	Pointers
		
		-
			Pointers to variable may be obtained by using the pointer command.
			
			For example:
				
				Meta: Integer
				x: 0
				
				Meta: Integer, Pointer
				y: Pointer: x
			
			will be cross compiled to:
				
				int x = 0;
				int* y = (*(x));
		-
	
	Addresses
		
		-
			Addresses to variable may be obtained by using the address command.
			
			For example:
				
				Meta: Integer
				x: 0
				
				Meta: Integer, Address
				y: Address: x
			
			will be cross compiled to:
				
				int x = 0;
				int& y = (&(x));
		-
	
	Lists
		
		-
			To define the content of an array inline, the list command may be used.
			
			For example:
				
				List: 1, 2, 3
			
			will be cross compiled to:
				
				{1, 2, 3}
			
			To access an element in an array, the at command may be used. Indexes start at one.
			
			For example:
				
				At: foo, 1
			
			will be cross compiled to:
				
				foo[(1) - 1]
			
			To reset the value of an element in an array, the set command may be used. Indexes
			start at one.
			
			For example:
				
				Set: foo, 1, 5
			
			will be cross compiled to:
				
				foo[(1) - 1] = 5;
		-
	
	Size
		
		-
			To retrieve the size of a variable or data type, the size command may be used.
			
			For example:
				
				Meta: Integer
				x: 0
				
				Size: Integer
				Size: x
			
			will be cross compiled to:
				
				int x = 0;
				
				sizeof(int)
				sizeof(x)
		-
	
	Math and Logic Operations
		
		-
			Math and logic operations work the same way they normally do in Kaeon FUSION. When
			cross compiled they will be in infix form surrounded by parentheses.
			
			For example:
				
				Add: 1, 2
				Add: 1, Divide: 10, 2
				Greater: 2, 1
			
			Will be cross compiled to:
				
				(1 + 2)
				(1 + (10 / 2))
				(2 > 1)
		-
	
	Flow Control
		
		-
			The scope command will cross compile to a do while loop that will always terminate
			after the first iteration.
			
			The break command will cross compile to a break statement nested within an if
			statement.
			
			The loop command will cross compile to a continue statement nested within an if
			statement.
			
			If the first child of a scope command is a break command, it will cross compile to a
			do while loop that will always terminate after the first iteration, nested inside an if
			statement.
			
			The else command will cross compile to a an else statement.
			
			If the first child of an else command is a break command, it will cross compile to a
			do while loop that will always terminate after the first iteration, nested inside an
			else if statement.
		-
	
	Including Header Files
		
		-
			Using the use command with the name of a header file as its child in a cross compiled
			definition will include the header file.
			
			For example:
				
				Define: foo
					Use: stdio.h
			
			will be cross compiled to:
				
				#include <stdio.h>
				
				void foo() {
					
				}
		-